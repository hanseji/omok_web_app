<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/>
	<link rel="apple-touch-icon" href="/images/icon-192.png" />
	<title>오목눈이</title>
</head>
<body>
<canvas id="canvas" width="400" height="400" style="background-color:#333"></canvas>
<video id="video" controls autoplay muted playsinline src="https://storage.googleapis.com/media-session/caminandes/short.mp4"></video>
<button id="togglePipButton">sdsdsdsd</button>

<script>
	/*
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let radius = canvas.height / 2;
ctx.translate(radius, radius);
radius = radius * 0.90
setInterval(drawClock, 1000);

function drawClock() {
  drawFace(ctx, radius);
  drawNumbers(ctx, radius);
  drawTime(ctx, radius);
}

function drawFace(ctx, radius) {
  const grad = ctx.createRadialGradient(0,0,radius*0.95, 0,0,radius*1.05);
  grad.addColorStop(0, '#333');
  grad.addColorStop(0.5, 'white');
  grad.addColorStop(1, '#333');
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, 2*Math.PI);
  ctx.fillStyle = 'white';
  ctx.fill();
  ctx.strokeStyle = grad;
  ctx.lineWidth = radius*0.1;
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0, 0, radius*0.1, 0, 2*Math.PI);
  ctx.fillStyle = '#333';
  ctx.fill();
}

function drawNumbers(ctx, radius) {
  ctx.font = radius*0.15 + "px arial";
  ctx.textBaseline="middle";
  ctx.textAlign="center";
  for(let num = 1; num < 13; num++){
	let ang = num * Math.PI / 6;
	ctx.rotate(ang);
	ctx.translate(0, -radius*0.85);
	ctx.rotate(-ang);
	ctx.fillText(num.toString(), 0, 0);
	ctx.rotate(ang);
	ctx.translate(0, radius*0.85);
	ctx.rotate(-ang);
  }
}

function drawTime(ctx, radius){
	const now = new Date();
	let hour = now.getHours();
	let minute = now.getMinutes();
	let second = now.getSeconds();
	//hour
	hour=hour%12;
	hour=(hour*Math.PI/6)+
	(minute*Math.PI/(6*60))+
	(second*Math.PI/(360*60));
	drawHand(ctx, hour, radius*0.5, radius*0.07);
	//minute
	minute=(minute*Math.PI/30)+(second*Math.PI/(30*60));
	drawHand(ctx, minute, radius*0.8, radius*0.07);
	// second
	second=(second*Math.PI/30);
	drawHand(ctx, second, radius*0.9, radius*0.02);
}

function drawHand(ctx, pos, length, width) {
	ctx.beginPath();
	ctx.lineWidth = width;
	ctx.lineCap = "round";
	ctx.moveTo(0,0);
	ctx.rotate(pos);
	ctx.lineTo(0, -length);
	ctx.stroke();
	ctx.rotate(-pos);
}*/

/*

	const video = document.getElementById('video');
	const pipButton = document.getElementById('togglePipButton');

	//video.srcObject = canvas.captureStream();

	video.addEventListener("pause", (event) => {
	alert(
		"The Boolean paused property is now 'true'. Either the pause() method was called or the autoplay attribute was toggled.",
	);
	});

	pipButton.addEventListener('click', async () => {
		// PiP 지원 여부 확인
		if ('pictureInPictureEnabled' in document) {
			try {
				// 이미 PiP 모드라면 나가기
				if (document.pictureInPictureElement) {
					await document.exitPictureInPicture();
				} else {
					// PiP 모드로 전환
					await video.requestPictureInPicture();
				}
			} catch (error) {
				alert(error)
				console.error('PiP 모드 전환에 실패했습니다:', error);
			}
		} else {
			alert('이 브라우저는 PiP 기능을 지원하지 않습니다.');
		}
	});
	*/
	if ('serviceWorker' in navigator) {
		navigator.serviceWorker.register('/sw.js');
	}
</script>
</body>
</html>